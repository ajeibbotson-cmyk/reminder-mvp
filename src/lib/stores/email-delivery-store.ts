import { create } from 'zustand'\nimport { subscribeWithSelector } from 'zustand/middleware'\nimport { immer } from 'zustand/middleware/immer'\nimport { \n  EmailDeliveryState,\n  EmailLogWithDetails,\n  EmailDeliveryFilters,\n  SendEmailData,\n  EmailEventType,\n  EmailAnalytics,\n  AnalyticsOptions,\n  ApiResponse\n} from '../types/store'\n\n// API utility functions\nconst api = {\n  async fetchEmailLogs(companyId: string, filters: EmailDeliveryFilters = {}): Promise<ApiResponse<{\n    emailLogs: EmailLogWithDetails[]\n    totalCount: number\n    hasMore: boolean\n    metrics: any\n  }>> {\n    const params = new URLSearchParams({ companyId })\n    \n    if (filters.templateId) params.append('templateId', filters.templateId)\n    if (filters.invoiceId) params.append('invoiceId', filters.invoiceId)\n    if (filters.customerId) params.append('customerId', filters.customerId)\n    if (filters.recipientEmail) params.append('recipientEmail', filters.recipientEmail)\n    if (filters.deliveryStatus) params.append('deliveryStatus', filters.deliveryStatus)\n    if (filters.language) params.append('language', filters.language)\n    if (filters.startDate) params.append('startDate', filters.startDate.toISOString())\n    if (filters.endDate) params.append('endDate', filters.endDate.toISOString())\n    if (filters.page) params.append('page', filters.page.toString())\n    if (filters.limit) params.append('limit', filters.limit.toString())\n\n    const response = await fetch(`/api/email/delivery?${params}`)\n    return response.json()\n  },\n\n  async sendEmail(emailData: SendEmailData): Promise<ApiResponse<EmailLogWithDetails>> {\n    const response = await fetch('/api/email/delivery', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(emailData)\n    })\n    return response.json()\n  },\n\n  async trackEmailEvent(\n    emailLogId: string, \n    eventType: EmailEventType, \n    eventData?: Record<string, any>\n  ): Promise<ApiResponse<void>> {\n    const response = await fetch(`/api/email/events/${emailLogId}`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ eventType, eventData })\n    })\n    return response.json()\n  },\n\n  async getAnalytics(companyId: string, options: AnalyticsOptions = {}): Promise<ApiResponse<EmailAnalytics>> {\n    const params = new URLSearchParams({ companyId })\n    \n    if (options.days) params.append('days', options.days.toString())\n    if (options.templateId) params.append('templateId', options.templateId)\n    if (options.templateType) params.append('templateType', options.templateType)\n\n    const response = await fetch(`/api/email/analytics?${params}`)\n    return response.json()\n  },\n\n  async resendEmail(emailLogId: string): Promise<ApiResponse<EmailLogWithDetails>> {\n    const response = await fetch(`/api/email/delivery/${emailLogId}/resend`, {\n      method: 'POST'\n    })\n    return response.json()\n  }\n}\n\nexport const useEmailDeliveryStore = create<EmailDeliveryState>()(subscribeWithSelector(immer((set, get) => ({\n  // State\n  emailLogs: [],\n  analytics: null,\n  loading: false,\n  error: null,\n  totalCount: 0,\n\n  // Actions\n  fetchEmailLogs: async (companyId: string, filters: EmailDeliveryFilters = {}) => {\n    set(state => {\n      state.loading = true\n      state.error = null\n    })\n\n    try {\n      const result = await api.fetchEmailLogs(companyId, filters)\n      \n      if (result.success && result.data) {\n        set(state => {\n          state.emailLogs = result.data!.emailLogs\n          state.totalCount = result.data!.totalCount\n          state.loading = false\n        })\n      } else {\n        throw new Error(result.error || 'Failed to fetch email logs')\n      }\n    } catch (error) {\n      set(state => {\n        state.error = error instanceof Error ? error.message : 'Failed to fetch email logs'\n        state.loading = false\n      })\n    }\n  },\n\n  sendEmail: async (emailData: SendEmailData) => {\n    set(state => {\n      state.loading = true\n      state.error = null\n    })\n\n    try {\n      const result = await api.sendEmail(emailData)\n      \n      if (result.success && result.data) {\n        set(state => {\n          state.loading = false\n          // Add the new email log to the beginning of the list\n          state.emailLogs.unshift(result.data!)\n          state.totalCount += 1\n        })\n        \n        return result.data.id\n      } else {\n        throw new Error(result.error || 'Failed to send email')\n      }\n    } catch (error) {\n      set(state => {\n        state.error = error instanceof Error ? error.message : 'Failed to send email'\n        state.loading = false\n      })\n      throw error\n    }\n  },\n\n  trackEmailEvent: async (emailLogId: string, eventType: EmailEventType, eventData?: Record<string, any>) => {\n    try {\n      const result = await api.trackEmailEvent(emailLogId, eventType, eventData)\n      \n      if (result.success) {\n        set(state => {\n          // Update email log in local state\n          const emailIndex = state.emailLogs.findIndex(log => log.id === emailLogId)\n          if (emailIndex !== -1) {\n            const emailLog = state.emailLogs[emailIndex]\n            \n            // Update based on event type\n            switch (eventType) {\n              case 'OPENED':\n                emailLog.openedAt = new Date()\n                emailLog.deliveryStatus = 'OPENED'\n                break\n              case 'CLICKED':\n                emailLog.clickedAt = new Date()\n                emailLog.deliveryStatus = 'CLICKED'\n                break\n              case 'BOUNCED':\n                emailLog.bouncedAt = new Date()\n                emailLog.deliveryStatus = 'BOUNCED'\n                emailLog.bounceReason = eventData?.reason || 'Email bounced'\n                break\n              case 'COMPLAINED':\n                emailLog.complainedAt = new Date()\n                emailLog.deliveryStatus = 'COMPLAINED'\n                emailLog.complaintFeedback = eventData?.feedback || 'Spam complaint'\n                break\n              case 'UNSUBSCRIBED':\n                emailLog.unsubscribedAt = new Date()\n                emailLog.deliveryStatus = 'UNSUBSCRIBED'\n                break\n            }\n            \n            emailLog.updatedAt = new Date()\n          }\n        })\n      } else {\n        throw new Error(result.error || 'Failed to track email event')\n      }\n    } catch (error) {\n      console.error('Failed to track email event:', error)\n      throw error\n    }\n  },\n\n  getAnalytics: async (companyId: string, options: AnalyticsOptions = {}) => {\n    set(state => {\n      state.loading = true\n      state.error = null\n    })\n\n    try {\n      const result = await api.getAnalytics(companyId, options)\n      \n      if (result.success && result.data) {\n        set(state => {\n          state.analytics = result.data!\n          state.loading = false\n        })\n        \n        return result.data\n      } else {\n        throw new Error(result.error || 'Failed to fetch analytics')\n      }\n    } catch (error) {\n      set(state => {\n        state.error = error instanceof Error ? error.message : 'Failed to fetch analytics'\n        state.loading = false\n      })\n      throw error\n    }\n  },\n\n  resendEmail: async (emailLogId: string) => {\n    set(state => {\n      state.loading = true\n      state.error = null\n    })\n\n    try {\n      const result = await api.resendEmail(emailLogId)\n      \n      if (result.success && result.data) {\n        set(state => {\n          state.loading = false\n          // Add the resent email log to the beginning of the list\n          state.emailLogs.unshift(result.data!)\n          state.totalCount += 1\n        })\n        \n        return result.data.id\n      } else {\n        throw new Error(result.error || 'Failed to resend email')\n      }\n    } catch (error) {\n      set(state => {\n        state.error = error instanceof Error ? error.message : 'Failed to resend email'\n        state.loading = false\n      })\n      throw error\n    }\n  },\n\n  clearError: () => {\n    set(state => {\n      state.error = null\n    })\n  },\n\n  clearAnalytics: () => {\n    set(state => {\n      state.analytics = null\n    })\n  }\n})))\n\n// Utility functions for email delivery management\nexport const emailDeliveryUtils = {\n  /**\n   * Get delivery status display information\n   */\n  getDeliveryStatusInfo: (status: string) => {\n    const statusMap = {\n      QUEUED: { label: 'Queued', color: 'gray', description: 'Waiting to be sent', icon: '⏳' },\n      SENT: { label: 'Sent', color: 'blue', description: 'Email has been sent', icon: '📤' },\n      DELIVERED: { label: 'Delivered', color: 'green', description: 'Email was delivered', icon: '✅' },\n      OPENED: { label: 'Opened', color: 'blue', description: 'Recipient opened the email', icon: '👁️' },\n      CLICKED: { label: 'Clicked', color: 'purple', description: 'Recipient clicked a link', icon: '🔗' },\n      BOUNCED: { label: 'Bounced', color: 'red', description: 'Email bounced', icon: '❌' },\n      COMPLAINED: { label: 'Spam', color: 'red', description: 'Marked as spam', icon: '🚫' },\n      UNSUBSCRIBED: { label: 'Unsubscribed', color: 'orange', description: 'Recipient unsubscribed', icon: '🚪' },\n      FAILED: { label: 'Failed', color: 'red', description: 'Failed to send', icon: '⚠️' }\n    }\n    \n    return statusMap[status as keyof typeof statusMap] || { \n      label: status, \n      color: 'gray', \n      description: '', \n      icon: '📧' \n    }\n  },\n\n  /**\n   * Calculate engagement score for an email\n   */\n  calculateEngagementScore: (emailLog: EmailLogWithDetails): number => {\n    let score = 0\n    \n    if (emailLog.deliveredAt) score += 25 // Delivered\n    if (emailLog.openedAt) score += 35 // Opened\n    if (emailLog.clickedAt) score += 40 // Clicked\n    \n    // Penalize negative actions\n    if (emailLog.bouncedAt) score = 0\n    if (emailLog.complainedAt) score = 0\n    if (emailLog.unsubscribedAt) score = Math.max(0, score - 50)\n    \n    return Math.min(100, score)\n  },\n\n  /**\n   * Get email timing analysis\n   */\n  getTimingAnalysis: (emailLog: EmailLogWithDetails) => {\n    const sentTime = emailLog.sentAt\n    const deliveredTime = emailLog.deliveredAt\n    const openedTime = emailLog.openedAt\n    const clickedTime = emailLog.clickedAt\n\n    const analysis = {\n      deliveryTime: null as number | null,\n      timeToOpen: null as number | null,\n      timeToClick: null as number | null,\n      totalEngagementTime: null as number | null\n    }\n\n    if (sentTime && deliveredTime) {\n      analysis.deliveryTime = new Date(deliveredTime).getTime() - new Date(sentTime).getTime()\n    }\n\n    if (deliveredTime && openedTime) {\n      analysis.timeToOpen = new Date(openedTime).getTime() - new Date(deliveredTime).getTime()\n    }\n\n    if (openedTime && clickedTime) {\n      analysis.timeToClick = new Date(clickedTime).getTime() - new Date(openedTime).getTime()\n    }\n\n    if (sentTime && clickedTime) {\n      analysis.totalEngagementTime = new Date(clickedTime).getTime() - new Date(sentTime).getTime()\n    }\n\n    return analysis\n  },\n\n  /**\n   * Format timing duration for display\n   */\n  formatDuration: (milliseconds: number): string => {\n    const seconds = Math.floor(milliseconds / 1000)\n    const minutes = Math.floor(seconds / 60)\n    const hours = Math.floor(minutes / 60)\n    const days = Math.floor(hours / 24)\n\n    if (days > 0) return `${days}d ${hours % 24}h`\n    if (hours > 0) return `${hours}h ${minutes % 60}m`\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`\n    return `${seconds}s`\n  },\n\n  /**\n   * Check if email was sent during UAE business hours\n   */\n  wasSentDuringBusinessHours: (emailLog: EmailLogWithDetails): boolean => {\n    const sendTime = emailLog.uaeSendTime || emailLog.sentAt\n    if (!sendTime) return false\n\n    const date = new Date(sendTime)\n    const dayOfWeek = date.getDay() // 0 = Sunday, 6 = Saturday\n    const hour = date.getHours()\n\n    // UAE business hours: Sunday-Thursday, 8 AM - 6 PM\n    return dayOfWeek >= 0 && dayOfWeek <= 4 && hour >= 8 && hour < 18\n  },\n\n  /**\n   * Get recommended actions based on email status\n   */\n  getRecommendedActions: (emailLog: EmailLogWithDetails): string[] => {\n    const actions: string[] = []\n    const status = emailLog.deliveryStatus\n\n    switch (status) {\n      case 'QUEUED':\n        actions.push('Check email queue status')\n        break\n      case 'BOUNCED':\n        actions.push('Verify recipient email address')\n        actions.push('Remove from mailing list if hard bounce')\n        break\n      case 'COMPLAINED':\n        actions.push('Review email content for spam triggers')\n        actions.push('Remove recipient from future campaigns')\n        break\n      case 'FAILED':\n        actions.push('Check email service configuration')\n        actions.push('Retry sending')\n        break\n      case 'DELIVERED':\n        if (!emailLog.openedAt) {\n          actions.push('Consider A/B testing subject lines')\n          actions.push('Check send time optimization')\n        }\n        break\n      case 'OPENED':\n        if (!emailLog.clickedAt) {\n          actions.push('Review email content and call-to-action')\n          actions.push('Optimize email design for clicks')\n        }\n        break\n    }\n\n    return actions\n  },\n\n  /**\n   * Group email logs by recipient for analysis\n   */\n  groupByRecipient: (emailLogs: EmailLogWithDetails[]) => {\n    return emailLogs.reduce((acc: Record<string, EmailLogWithDetails[]>, log) => {\n      if (!acc[log.recipientEmail]) {\n        acc[log.recipientEmail] = []\n      }\n      acc[log.recipientEmail].push(log)\n      return acc\n    }, {})\n  },\n\n  /**\n   * Calculate delivery metrics for a set of emails\n   */\n  calculateMetrics: (emailLogs: EmailLogWithDetails[]) => {\n    const total = emailLogs.length\n    if (total === 0) return null\n\n    const delivered = emailLogs.filter(log => log.deliveryStatus === 'DELIVERED' || log.deliveredAt).length\n    const opened = emailLogs.filter(log => log.openedAt).length\n    const clicked = emailLogs.filter(log => log.clickedAt).length\n    const bounced = emailLogs.filter(log => log.deliveryStatus === 'BOUNCED').length\n    const complained = emailLogs.filter(log => log.deliveryStatus === 'COMPLAINED').length\n\n    return {\n      total,\n      delivered,\n      opened,\n      clicked,\n      bounced,\n      complained,\n      deliveryRate: total > 0 ? Math.round((delivered / total) * 10000) / 100 : 0,\n      openRate: delivered > 0 ? Math.round((opened / delivered) * 10000) / 100 : 0,\n      clickRate: opened > 0 ? Math.round((clicked / opened) * 10000) / 100 : 0,\n      bounceRate: total > 0 ? Math.round((bounced / total) * 10000) / 100 : 0,\n      complaintRate: total > 0 ? Math.round((complained / total) * 10000) / 100 : 0\n    }\n  },\n\n  /**\n   * Filter emails by date range\n   */\n  filterByDateRange: (emailLogs: EmailLogWithDetails[], days: number) => {\n    const cutoffDate = new Date()\n    cutoffDate.setDate(cutoffDate.getDate() - days)\n    \n    return emailLogs.filter(log => new Date(log.createdAt) >= cutoffDate)\n  },\n\n  /**\n   * Get top performing templates\n   */\n  getTopTemplates: (emailLogs: EmailLogWithDetails[], limit = 5) => {\n    const templateStats: Record<string, any> = {}\n\n    emailLogs.forEach(log => {\n      if (!log.templateId || !log.emailTemplates) return\n\n      const templateId = log.templateId\n      if (!templateStats[templateId]) {\n        templateStats[templateId] = {\n          templateId,\n          templateName: log.emailTemplates.name,\n          templateType: log.emailTemplates.templateType,\n          total: 0,\n          delivered: 0,\n          opened: 0,\n          clicked: 0\n        }\n      }\n\n      const stats = templateStats[templateId]\n      stats.total++\n      if (log.deliveredAt) stats.delivered++\n      if (log.openedAt) stats.opened++\n      if (log.clickedAt) stats.clicked++\n    })\n\n    return Object.values(templateStats)\n      .map((stats: any) => ({\n        ...stats,\n        deliveryRate: stats.total > 0 ? Math.round((stats.delivered / stats.total) * 100) : 0,\n        openRate: stats.delivered > 0 ? Math.round((stats.opened / stats.delivered) * 100) : 0,\n        clickRate: stats.opened > 0 ? Math.round((stats.clicked / stats.opened) * 100) : 0\n      }))\n      .sort((a, b) => b.total - a.total)\n      .slice(0, limit)\n  }\n}\n\n// Export the store hook for easy use in components\nexport default useEmailDeliveryStore"