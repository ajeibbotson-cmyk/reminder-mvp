import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { 
  EmailTemplateState,
  EmailTemplateWithDetails,
  EmailTemplateFilters,
  ApiResponse
} from '../types/store'
import { EmailTemplate, EmailTemplateType } from '@prisma/client'

// API utility functions
const api = {
  async fetchTemplates(companyId: string, filters: EmailTemplateFilters = {}): Promise<ApiResponse<{
    templates: EmailTemplateWithDetails[]
    totalCount: number
    hasMore: boolean
    summary: any
  }>> {
    const params = new URLSearchParams({ companyId })
    
    if (filters.templateType) params.append('templateType', filters.templateType)
    if (filters.isActive !== undefined) params.append('isActive', filters.isActive.toString())
    if (filters.isDefault !== undefined) params.append('isDefault', filters.isDefault.toString())
    if (filters.language) params.append('language', filters.language)
    if (filters.search) params.append('search', filters.search)
    if (filters.page) params.append('page', filters.page.toString())
    if (filters.limit) params.append('limit', filters.limit.toString())

    const response = await fetch(`/api/email/templates?${params}`)
    return response.json()
  },

  async createTemplate(templateData: Omit<EmailTemplate, 'id' | 'createdAt' | 'updatedAt'>): Promise<ApiResponse<EmailTemplate>> {
    const response = await fetch('/api/email/templates', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(templateData)
    })
    return response.json()
  },

  async updateTemplate(id: string, updates: Partial<EmailTemplate>): Promise<ApiResponse<EmailTemplate>> {
    const response = await fetch(`/api/email/templates/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    })
    return response.json()
  },

  async deleteTemplate(id: string): Promise<ApiResponse<{ action: string; templateId: string }>> {
    const response = await fetch(`/api/email/templates/${id}`, {
      method: 'DELETE'
    })
    return response.json()
  },

  async getTemplateById(id: string): Promise<ApiResponse<EmailTemplateWithDetails>> {
    const response = await fetch(`/api/email/templates/${id}`)
    return response.json()
  }
}

export const useEmailTemplateStore = create<EmailTemplateState>()(subscribeWithSelector(immer((set, get) => ({
  // State
  templates: [],
  currentTemplate: null,
  loading: false,
  error: null,
  totalCount: 0,

  // Actions
  fetchTemplates: async (companyId: string, filters: EmailTemplateFilters = {}) => {
    set(state => {
      state.loading = true
      state.error = null
    })

    try {
      const result = await api.fetchTemplates(companyId, filters)
      
      if (result.success && result.data) {
        set(state => {
          state.templates = result.data!.templates
          state.totalCount = result.data!.totalCount
          state.loading = false
        })
      } else {
        throw new Error(result.error || 'Failed to fetch email templates')
      }
    } catch (error) {
      set(state => {
        state.error = error instanceof Error ? error.message : 'Failed to fetch email templates'
        state.loading = false
      })
    }
  },

  createTemplate: async (templateData: Omit<EmailTemplate, 'id' | 'createdAt' | 'updatedAt'>) => {
    set(state => {
      state.loading = true
      state.error = null
    })

    try {
      const result = await api.createTemplate(templateData)
      
      if (result.success && result.data) {
        set(state => {
          state.loading = false
        })
        
        // Refresh templates to include the new one
        await get().fetchTemplates(templateData.companyId)
        
        return result.data
      } else {
        throw new Error(result.error || 'Failed to create email template')
      }
    } catch (error) {
      set(state => {
        state.error = error instanceof Error ? error.message : 'Failed to create email template'
        state.loading = false
      })
      throw error
    }
  },

  updateTemplate: async (id: string, updates: Partial<EmailTemplate>) => {
    set(state => {
      state.loading = true
      state.error = null
    })

    try {
      const result = await api.updateTemplate(id, updates)
      
      if (result.success && result.data) {
        set(state => {
          state.loading = false
          
          // Update template in local state
          const templateIndex = state.templates.findIndex(t => t.id === id)
          if (templateIndex !== -1) {
            state.templates[templateIndex] = { ...state.templates[templateIndex], ...updates }
          }
          
          // Update current template if it's the one being updated
          if (state.currentTemplate?.id === id) {
            state.currentTemplate = { ...state.currentTemplate, ...updates }
          }
        })
      } else {
        throw new Error(result.error || 'Failed to update email template')
      }
    } catch (error) {
      set(state => {
        state.error = error instanceof Error ? error.message : 'Failed to update email template'
        state.loading = false
      })
      throw error
    }
  },

  deleteTemplate: async (id: string) => {
    set(state => {
      state.loading = true
      state.error = null
    })

    try {
      const result = await api.deleteTemplate(id)
      
      if (result.success) {
        set(state => {
          state.loading = false
          
          // Remove template from local state if actually deleted
          if (result.data?.action === 'deleted') {
            state.templates = state.templates.filter(t => t.id !== id)
            state.totalCount = Math.max(0, state.totalCount - 1)
          } else if (result.data?.action === 'deactivated') {
            // Update template status to inactive
            const templateIndex = state.templates.findIndex(t => t.id === id)
            if (templateIndex !== -1) {
              state.templates[templateIndex].isActive = false
            }
          }
          
          // Clear current template if it was deleted/deactivated
          if (state.currentTemplate?.id === id) {
            state.currentTemplate = null
          }
        })
      } else {
        throw new Error(result.error || 'Failed to delete email template')
      }
    } catch (error) {
      set(state => {
        state.error = error instanceof Error ? error.message : 'Failed to delete email template'
        state.loading = false
      })
      throw error
    }
  },

  duplicateTemplate: async (id: string, newName: string) => {
    const templateToDuplicate = get().templates.find(t => t.id === id)
    if (!templateToDuplicate) {
      throw new Error('Template not found')
    }

    const duplicateData = {
      companyId: templateToDuplicate.companyId,
      name: newName,
      description: `Copy of ${templateToDuplicate.description || templateToDuplicate.name}`,
      templateType: templateToDuplicate.templateType,
      subjectEn: templateToDuplicate.subjectEn,
      subjectAr: templateToDuplicate.subjectAr,
      contentEn: templateToDuplicate.contentEn,
      contentAr: templateToDuplicate.contentAr,
      variables: templateToDuplicate.variables,
      isActive: true,
      isDefault: false, // Duplicates are never default
      uaeBusinessHoursOnly: templateToDuplicate.uaeBusinessHoursOnly,
      createdBy: templateToDuplicate.createdBy
    }

    return get().createTemplate(duplicateData)
  },

  setAsDefault: async (id: string, templateType: EmailTemplateType) => {
    try {
      await get().updateTemplate(id, { isDefault: true, templateType })
      
      // Update other templates of same type to not be default
      set(state => {
        state.templates.forEach(template => {
          if (template.templateType === templateType && template.id !== id) {
            template.isDefault = false
          }
        })
      })
    } catch (error) {
      throw error
    }
  },

  getTemplateById: (id: string) => {
    return get().templates.find(t => t.id === id) || null
  },

  clearError: () => {
    set(state => {
      state.error = null
    })
  }
})));

// Utility functions for template management
export const emailTemplateUtils = {
  /**
   * Get template type display information
   */
  getTemplateTypeInfo: (type: EmailTemplateType) => {
    const typeMap = {
      FOLLOW_UP: { 
        label: 'Follow-up', 
        description: 'Payment reminder emails', 
        icon: 'üìß',
        color: 'blue' 
      },
      WELCOME: { 
        label: 'Welcome', 
        description: 'Customer welcome emails', 
        icon: 'üëã',
        color: 'green' 
      },
      INVOICE_REMINDER: { 
        label: 'Invoice Reminder', 
        description: 'Invoice payment reminders', 
        icon: 'üí≥',
        color: 'orange' 
      },
      PAYMENT_CONFIRMATION: { 
        label: 'Payment Confirmation', 
        description: 'Payment received confirmations', 
        icon: '‚úÖ',
        color: 'green' 
      },
      OVERDUE_NOTICE: { 
        label: 'Overdue Notice', 
        description: 'Overdue payment notices', 
        icon: '‚ö†Ô∏è',
        color: 'red' 
      },
      SYSTEM_NOTIFICATION: { 
        label: 'System Notification', 
        description: 'System-generated notifications', 
        icon: 'üîî',
        color: 'gray' 
      }
    }
    
    return typeMap[type] || { 
      label: type, 
      description: '', 
      icon: 'üìÑ',
      color: 'gray' 
    }
  },

  /**
   * Validate template content
   */
  validateTemplate: (template: Partial<EmailTemplate>): string[] => {
    const errors: string[] = []

    if (!template.name?.trim()) {
      errors.push('Template name is required')
    }

    if (!template.subjectEn?.trim()) {
      errors.push('English subject is required')
    }

    if (!template.contentEn?.trim()) {
      errors.push('English content is required')
    }

    // Check for balanced template variables
    const content = (template.contentEn || '') + (template.subjectEn || '')
    const openBraces = (content.match(/{{/g) || []).length
    const closeBraces = (content.match(/}}/g) || []).length
    
    if (openBraces !== closeBraces) {
      errors.push('Template variables have unmatched braces')
    }

    return errors
  },

  /**
   * Extract template variables from content
   */
  extractVariables: (content: string): string[] => {
    const variableRegex = /{{(\w+)}}/g
    const variables: string[] = []
    let match

    while ((match = variableRegex.exec(content)) !== null) {
      if (!variables.includes(match[1])) {
        variables.push(match[1])
      }
    }

    return variables.sort()
  },

  /**
   * Get available template variables for different contexts
   */
  getAvailableVariables: () => {
    return {
      invoice: [
        'invoiceNumber', 'invoiceAmount', 'invoiceSubtotal', 'invoiceVatAmount',
        'invoiceTotalAmount', 'invoiceCurrency', 'invoiceStatus', 'invoiceDueDate',
        'invoiceDescription', 'daysPastDue', 'totalPaid', 'outstandingAmount',
        'itemCount', 'lastPaymentDate'
      ],
      customer: [
        'customerName', 'customerNameAr', 'customerEmail', 'customerPhone',
        'customerPaymentTerms', 'customerNotes', 'outstandingInvoiceCount',
        'totalOutstanding'
      ],
      company: [
        'companyName', 'companyTrn', 'supportEmail', 'supportPhone'
      ],
      system: [
        'currentDate', 'currentDateAr', 'currentTime', 'businessYear'
      ]
    }
  },

  /**
   * Generate preview content with sample data
   */
  generatePreview: (content: string, language: 'en' | 'ar' = 'en'): string => {
    const sampleData = {
      invoiceNumber: 'INV-2025-001',
      invoiceAmount: language === 'ar' ? '1,250.00 ÿØ.ÿ•' : 'AED 1,250.00',
      customerName: language === 'ar' ? 'ÿ¥ÿ±ŸÉÿ© ÿßŸÑÿ•ŸÖÿßÿ±ÿßÿ™ ŸÑŸÑÿ™ÿ¨ÿßÿ±ÿ©' : 'Emirates Trading Company',
      companyName: language === 'ar' ? 'ÿ¥ÿ±ŸÉÿ© ÿßŸÑŸÅŸàÿßÿ™Ÿäÿ± ÿßŸÑÿ∞ŸÉŸäÿ©' : 'Smart Invoice Solutions',
      dueDate: language === 'ar' ? '15 ŸäŸÜÿßŸäÿ± 2025' : 'January 15, 2025',
      daysPastDue: '5',
      currentDate: language === 'ar' ? '20 ŸäŸÜÿßŸäÿ± 2025' : 'January 20, 2025'
    }

    let preview = content
    Object.entries(sampleData).forEach(([key, value]) => {
      const regex = new RegExp(`{{${key}}}`, 'g')
      preview = preview.replace(regex, value)
    })

    return preview
  },

  /**
   * Check if template has Arabic content
   */
  hasArabicContent: (template: EmailTemplate): boolean => {
    return !!(template.subjectAr || template.contentAr)
  },

  /**
   * Get template usage statistics
   */
  getUsageStats: (template: EmailTemplateWithDetails) => {
    const totalSent = template.emailLogs?.length || 0
    const recentSent = template.emailLogs?.filter(log => {
      const thirtyDaysAgo = new Date()
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
      return new Date(log.createdAt) >= thirtyDaysAgo
    }).length || 0

    return {
      totalSent,
      recentSent,
      lastUsed: totalSent > 0 ? template.emailLogs?.[0]?.createdAt : null,
      isPopular: recentSent > 10
    }
  },

  /**
   * Sort templates by relevance (default first, then by usage, then by date)
   */
  sortTemplatesByRelevance: (templates: EmailTemplateWithDetails[]): EmailTemplateWithDetails[] => {
    return [...templates].sort((a, b) => {
      // Default templates first
      if (a.isDefault !== b.isDefault) {
        return a.isDefault ? -1 : 1
      }
      
      // Then by usage (total email logs)
      const aUsage = a.emailLogs?.length || 0
      const bUsage = b.emailLogs?.length || 0
      if (aUsage !== bUsage) {
        return bUsage - aUsage
      }
      
      // Finally by update date
      return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    })
  }
}

// Export the store hook for easy use in components
export default useEmailTemplateStore